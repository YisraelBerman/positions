pipeline {
    agent {
        label 'agent1'
    }

    environment {
        GITHUB_TOKEN = credentials('github-token')
        GITHUB_USER = credentials('github-user')
        AWS_APPS_IP = credentials('AWS_apps_IP') 
        SSH_TARGET = "ubuntu@${env.AWS_APPS_IP}"
    }

    stages {  
        stage('Check Commit Message') {
            steps {
                script {
                    // Get commit message and store it in env variable
                    env.COMMIT_MESSAGE = sh(
                        script: "git log -1 --pretty=%B",
                        returnStdout: true
                    ).trim().toLowerCase()
                    
                    // Check if commit message starts with any valid type
                    def isValidMessage = ['breaking:', 'feat:', 'fix:'].any { type ->
                        env.COMMIT_MESSAGE.startsWith(type)
                    }
                    
                    if (!isValidMessage) {
                        echo "Commit message '${env.COMMIT_MESSAGE}' doesn't start with breaking:, feat:, or fix:. Skipping pipeline."
                        currentBuild.result = 'SUCCESS'
                        sh 'exit 0'
                    }
                }
            }
        } // Check Commit Message

        stage('Initialize and Get Versions') {
            steps {
                script {
                    // Ensure we have full history and tags
                    checkout([$class: 'GitSCM',
                            branches: [[name: '*/master']],
                            extensions: [[$class: 'CloneOption',
                                        noTags: false,
                                        shallow: false,
                                        depth: 0,
                                        reference: '']],
                            userRemoteConfigs: [[
                                credentialsId: 'github',
                                url: 'https://github.com/YisraelBerman/positions.git'
                            ]]])
                    
                    // Get commit message
                    def commitMessage = env.COMMIT_MESSAGE
                    
                    // Get the latest tag
                    def latestTag = sh(
                        script: 'git tag -l | sort -V | tail -n1 || true',
                        returnStdout: true
                    ).trim()
                    
                    echo "Found latest tag: ${latestTag}"
                    
                    // Get tag description
                    def tagDescription = sh(
                        script: "git tag -l --format='%(contents)' ${latestTag} || true",
                        returnStdout: true
                    ).trim()
                    
                    echo "Tag description: ${tagDescription}"
                    
                    // Parse app version (4 parts)
                    def (appMajor, appMinor, appPatch, appBuild) = latestTag.replaceAll('v', '').tokenize('.')
                    
                    // Parse component versions using string operations instead of regex
                    def descLines = tagDescription.split('\n')
                    
                    // Initialize versions with null to detect if they were found in tag description
                    def backendVersion = null
                    def frontendVersion = null
                    def adminfrontendVersion = null
                    
                    // Trim lines and parse versions
                    descLines.each { line ->
                        def trimmedLine = line.trim()
                        if (trimmedLine.startsWith('backend:')) {
                            backendVersion = trimmedLine.substring('backend:'.length()).trim()
                        } else if (trimmedLine.startsWith('frontend:')) {
                            frontendVersion = trimmedLine.substring('frontend:'.length()).trim()
                        } else if (trimmedLine.startsWith('admin-frontend:')) {
                            adminfrontendVersion = trimmedLine.substring('admin-frontend:'.length()).trim()
                        }
                    }
                    
                    // Set default versions only if not found in tag
                    backendVersion = backendVersion ?: '1.0.0'
                    frontendVersion = frontendVersion ?: '1.0.0'
                    adminfrontendVersion = adminfrontendVersion ?: '1.0.0'
                    
                    echo "Parsed versions from tag:"
                    echo "Backend from tag: ${backendVersion}"
                    echo "Frontend from tag: ${frontendVersion}"
                    echo "Admin-Frontend from tag: ${adminfrontendVersion}"
                    
                    // Store original versions
                    env.NEW_BACKEND_VERSION = backendVersion
                    env.NEW_FRONTEND_VERSION = frontendVersion
                    env.NEW_ADMINFRONTEND_VERSION = adminfrontendVersion
                    
                    // Check for changes
                    def backendChanges = sh(
                        script: 'git diff --name-only HEAD~1..HEAD | grep "app/backend/" || true',
                        returnStdout: true
                    ).trim()

                    def frontendChanges = sh(
                        script: 'git diff --name-only HEAD~1..HEAD | grep "app/frontend/" || true',
                        returnStdout: true
                    ).trim()

                    def adminfrontendChanges = sh(
                        script: 'git diff --name-only HEAD~1..HEAD | grep "app/admin-frontend/" || true',
                        returnStdout: true
                    ).trim()

                    env.BACKEND_CHANGED = backendChanges ? 'true' : 'false'
                    env.FRONTEND_CHANGED = frontendChanges ? 'true' : 'false'
                    env.ADMINFRONTEND_CHANGED = adminfrontendChanges ? 'true' : 'false'
                    
                    // Update app version based on commit message
                    if (commitMessage.startsWith('breaking')) {
                        appMinor = (appMinor.toInteger() + 1).toString()
                        appPatch = '0'
                        appBuild = '0'
                    } else if (commitMessage.startsWith('feat')) {
                        appPatch = (appPatch.toInteger() + 1).toString()
                        appBuild = '0'
                    } else if (commitMessage.startsWith('fix')) {
                        appBuild = (appBuild.toInteger() + 1).toString()
                    }
                    
                    // Only update backend version if changed
                    if (env.BACKEND_CHANGED == 'true') {
                        def (backendMajor, backendMinor, backendPatch) = backendVersion.tokenize('.')
                        if (commitMessage.startsWith('breaking')) {
                            backendMajor = (backendMajor.toInteger() + 1).toString()
                            backendMinor = '0'
                            backendPatch = '0'
                        } else if (commitMessage.startsWith('feat')) {
                            backendMinor = (backendMinor.toInteger() + 1).toString()
                            backendPatch = '0'
                        } else if (commitMessage.startsWith('fix')) {
                            backendPatch = (backendPatch.toInteger() + 1).toString()
                        }
                        env.NEW_BACKEND_VERSION = "${backendMajor}.${backendMinor}.${backendPatch}"
                        env.BUILD_BACKEND = 'true'
                    }
                    
                    // Only update frontend version if changed
                    if (env.FRONTEND_CHANGED == 'true') {
                        def (frontendMajor, frontendMinor, frontendPatch) = frontendVersion.tokenize('.')
                        if (commitMessage.startsWith('breaking')) {
                            frontendMajor = (frontendMajor.toInteger() + 1).toString()
                            frontendMinor = '0'
                            frontendPatch = '0'
                        } else if (commitMessage.startsWith('feat')) {
                            frontendMinor = (frontendMinor.toInteger() + 1).toString()
                            frontendPatch = '0'
                        } else if (commitMessage.startsWith('fix')) {
                            frontendPatch = (frontendPatch.toInteger() + 1).toString()
                        }
                        env.NEW_FRONTEND_VERSION = "${frontendMajor}.${frontendMinor}.${frontendPatch}"
                        env.BUILD_FRONTEND = 'true'
                    }

                    // Only update admin-frontend version if changed
                    if (env.ADMINFRONTEND_CHANGED == 'true') {
                        def (adminfrontendMajor, adminfrontendMinor, adminfrontendPatch) = adminfrontendVersion.tokenize('.')
                        if (commitMessage.startsWith('breaking')) {
                            adminfrontendMajor = (adminfrontendMajor.toInteger() + 1).toString()
                            adminfrontendMinor = '0'
                            adminfrontendPatch = '0'
                        } else if (commitMessage.startsWith('feat')) {
                            adminfrontendMinor = (adminfrontendMinor.toInteger() + 1).toString()
                            adminfrontendPatch = '0'
                        } else if (commitMessage.startsWith('fix')) {
                            adminfrontendPatch = (adminfrontendPatch.toInteger() + 1).toString()
                        }
                        env.NEW_ADMINFRONTEND_VERSION = "${adminfrontendMajor}.${adminfrontendMinor}.${adminfrontendPatch}"
                        env.BUILD_ADMINFRONTEND = 'true'
                    }
                    
                    // Set new app version
                    env.NEW_VERSION = "v${appMajor}.${appMinor}.${appPatch}.${appBuild}"
                    
                    echo "Setting versions:"
                    echo "App: ${env.NEW_VERSION}"
                    echo "Backend: ${env.NEW_BACKEND_VERSION} (changed: ${env.BACKEND_CHANGED})"
                    echo "Frontend: ${env.NEW_FRONTEND_VERSION} (changed: ${env.FRONTEND_CHANGED})"
                    echo "admin-Frontend: ${env.NEW_ADMINFRONTEND_VERSION} (changed: ${env.ADMINFRONTEND_CHANGED})"
                    
                    // Set up other environment variables
                    env.GIT_COMMIT_HASH = sh(script: "git log -n 1 --pretty=format:'%H'", returnStdout: true).trim()
                    env.SHORT_COMMIT = env.GIT_COMMIT_HASH.substring(0, 7)
                    env.REPO_PATH = "ghcr.io/yisraelberman/positions"
                    
                    // Define image names with versions
                    env.BACKEND_IMAGE = "${env.REPO_PATH}/backend:${env.NEW_BACKEND_VERSION}"
                    env.FRONTEND_IMAGE = "${env.REPO_PATH}/frontend:${env.NEW_FRONTEND_VERSION}"
                    env.ADMINFRONTEND_IMAGE = "${env.REPO_PATH}/adminfrontend:${env.NEW_ADMINFRONTEND_VERSION}"
                }
            }
        } // Initialize and Get Versions
        stage('Create Tag') {
            steps {
                script {
                    def tagMessage = """Release ${env.NEW_VERSION}
        backend: ${env.NEW_BACKEND_VERSION}
        frontend: ${env.NEW_FRONTEND_VERSION}
        admin-frontend: ${env.NEW_ADMINFRONTEND_VERSION}"""

                    withCredentials([usernamePassword(credentialsId: 'github', 
                                                usernameVariable: 'GIT_USERNAME', 
                                                passwordVariable: 'GIT_PASSWORD')]) {
                        sh """
                            git config user.email "jenkins@example.com"
                            git config user.name "Jenkins"
                            git config credential.helper '!f() { echo "username=${GIT_USERNAME}"; echo "password=${GIT_PASSWORD}"; }; f'
                            git tag -a ${env.NEW_VERSION} -m "${tagMessage}"
                            git push https://github.com/YisraelBerman/positions.git ${env.NEW_VERSION}
                            git config --unset credential.helper
                        """
                    }
                }
            }
        } // Create Tag
        
        stage('Test') {
            steps {
                echo 'To be added someday.'
            }
        } // test

        stage('Build') {
            parallel {
                stage('Build Backend') {
                    when {
                        expression {
                            return env.BACKEND_CHANGED == 'true'
                        }
                    }
                    steps {
                        script {
                            echo 'Changes detected in the backend directory. Building backend image...'
                            sh "docker build -t ${env.BACKEND_IMAGE} -f ./app/backend/dockerfile ./app/backend"
                            env.BUILD_BACKEND = 'true' 
                        }
                    }
                }
                stage('Build Frontend') {
                    when {
                        expression {
                            return env.FRONTEND_CHANGED == 'true'
                        }
                    }
                    steps {
                        script {
                            echo 'Changes detected in the frontend directory. Building frontend image...'
                            sh """
                                docker build \
                                    --build-arg REACT_APP_BACKEND_URL=https://app.yisraelberman.com:5000 \
                                    -t ${env.FRONTEND_IMAGE} \
                                    -f ./app/frontend/dockerfile ./app/frontend
                            """
                            env.BUILD_FRONTEND = 'true' 
                        }
                    }
                }
                stage('Build admin-Frontend') {
                    when {
                        expression {
                            return env.ADMINFRONTEND_CHANGED == 'true'
                        }
                    }
                    steps {
                        script {
                            echo 'Changes detected in the admin-frontend directory. Building admin-frontend image...'
                            sh """
                                docker build \
                                    --build-arg REACT_APP_API_BASE_URL=https://app.yisraelberman.com:5000/api \
                                    -t ${env.ADMINFRONTEND_IMAGE} \
                                    -f ./app/admin- frontend/dockerfile ./app/admin-frontend
                            """                        
                            
                            env.BUILD_FRONTEND = 'true' 
                        }
                    }
                }
            }
        } // Build

        stage('Docker Login') {
            when {
                expression { return env.BUILD_BACKEND == 'true' || env.BUILD_FRONTEND == 'true' }
            }
            steps {
                sh "echo ${env.GITHUB_TOKEN} | docker login ghcr.io -u ${env.GITHUB_USER} --password-stdin"
            }
        } // Docker Login

        stage('Push Images to GitHub') {
            parallel {
                stage('Push Backend Image') {
                    when {
                        expression { return env.BUILD_BACKEND == 'true' }
                    }
                    steps {
                        script {
                            echo "Pushing backend image version ${env.NEW_BACKEND_VERSION}..."
                            sh "docker push ${env.BACKEND_IMAGE}"
                        }
                    }
                }
                stage('Push Frontend Image') {
                    when {
                        expression { return env.BUILD_FRONTEND == 'true' }
                    }
                    steps {
                        script {
                            echo "Pushing frontend image version ${env.NEW_FRONTEND_VERSION}..."
                            sh "docker push ${env.FRONTEND_IMAGE}"
                        }
                    }
                }
                stage('Push admin-Frontend Image') {
                    when {
                        expression { return env.BUILD_ADMINFRONTEND == 'true' }
                    }
                    steps {
                        script {
                            echo "Pushing admin-frontend image version ${env.NEW_ADMINFRONTEND_VERSION}..."
                            sh "docker push ${env.ADMINFRONTEND_IMAGE}"
                        }
                    }
                }
            }
        } // Push Images to GitHub

        stage('Deploy') {
            when {
                expression { return env.BUILD_BACKEND == 'true' || env.BUILD_FRONTEND == 'true' || env.BUILD_ADMINFRONTEND == 'true' }
            }
            steps {
                script {
                    withCredentials([sshUserPrivateKey(credentialsId: 'forssh', keyFileVariable: 'secret')]) {
                        if (env.BUILD_BACKEND == 'true') {
                            sh """
                            ssh -o StrictHostKeyChecking=no -i "$secret" ${env.SSH_TARGET} "
                                sudo docker stop backend || true && sudo docker rm backend || true && \
                                sudo docker pull ${env.BACKEND_IMAGE} && \
                                sudo docker run -d --name backend -p 5000:5000 \
                                --env-file ~/backend/.env \
                                -e FLASK_ENV=production \
                                -e CORS_ORIGIN=https://app.yisraelberman.com \
                                -v /etc/letsencrypt/live/app.yisraelberman.com/fullchain.pem:/etc/letsencrypt/live/app.yisraelberman.com/fullchain.pem:ro \
                                -v /etc/letsencrypt/live/app.yisraelberman.com/privkey.pem:/etc/letsencrypt/live/app.yisraelberman.com/privkey.pem:ro \
                                ${env.BACKEND_IMAGE}
                            "
                            """
                        }

                        // Always restart frontend with new version
                        sh """
                        ssh -o StrictHostKeyChecking=no -i "$secret" ${env.SSH_TARGET} "
                            sudo docker stop frontend || true && sudo docker rm frontend || true;
                            ${env.BUILD_FRONTEND == 'true' ? "sudo docker pull ${env.FRONTEND_IMAGE};" : ''}
                            sudo docker run -d --name frontend -p 443:3002 \
                            -e VERSION='${env.NEW_VERSION}' \
                            -v /etc/letsencrypt/live/app.yisraelberman.com/fullchain.pem:/etc/letsencrypt/live/app.yisraelberman.com/fullchain.pem:ro \
                            -v /etc/letsencrypt/live/app.yisraelberman.com/privkey.pem:/etc/letsencrypt/live/app.yisraelberman.com/privkey.pem:ro \
                            ${env.FRONTEND_IMAGE};
                        "
                        """

                        // Always restart admin-frontend with new version
                        sh """
                        ssh -o StrictHostKeyChecking=no -i "$secret" ${env.SSH_TARGET} "
                            sudo docker stop adminfrontend || true && sudo docker rm adminfrontend || true;
                            ${env.BUILD_ADMINFRONTEND == 'true' ? "sudo docker pull ${env.ADMINFRONTEND_IMAGE};" : ''}
                            sudo docker run -d --name adminfrontend -p 3001:3001 \
                            -e REACT_APP_BACKEND_URL=https://app.yisraelberman.com:5000 \

                            -v /etc/letsencrypt/live/app.yisraelberman.com/fullchain.pem:/etc/letsencrypt/live/app.yisraelberman.com/fullchain.pem:ro \
                            -v /etc/letsencrypt/live/app.yisraelberman.com/privkey.pem:/etc/letsencrypt/live/app.yisraelberman.com/privkey.pem:ro \
                            ${env.ADMINFRONTEND_IMAGE};
                        "
                        """
                    }
                }
            }
        } // Deploy
    }

    post {
        always {
            cleanWs()
        }
    }
}