pipeline {
    agent {
        label 'agent1'
    }

    environment {
        GITHUB_TOKEN = credentials('github-token')
        GITHUB_USER = credentials('github-user')
        AWS_APPS_IP = credentials('AWS_apps_IP') 
        SSH_TARGET = "ubuntu@${env.AWS_APPS_IP}"
    }

    stages {  
        stage('Initialize and Get Versions') {
            steps {
                script {
                    // Ensure we have full history and tags
                    checkout([$class: 'GitSCM',
                            branches: [[name: '*/master']],
                            extensions: [[$class: 'CloneOption',
                                        noTags: false,
                                        shallow: false,
                                        depth: 0,
                                        reference: '']],
                            userRemoteConfigs: [[
                                credentialsId: 'github',
                                url: 'https://github.com/YisraelBerman/positions.git'
                            ]]])
                    
                    // Get commit message
                    def commitMessage = sh(
                        script: "git log -1 --pretty=%B",
                        returnStdout: true
                    ).trim().toLowerCase()
                    
                    /* Default values if needed in the future
                    env.NEW_VERSION = 'v1.0.0.0'
                    env.NEW_BACKEND_VERSION = '1.0.0'
                    env.NEW_FRONTEND_VERSION = '1.0.0'
                    */
                    
                    // Get the latest tag
                    def latestTag = sh(
                        script: 'git tag -l | sort -V | tail -n1 || true',
                        returnStdout: true
                    ).trim()
                    
                    echo "Found latest tag: ${latestTag}"
                    
                    // Get tag description
                    def tagDescription = sh(
                        script: "git tag -l --format='%(contents)' ${latestTag} || true",
                        returnStdout: true
                    ).trim()
                    
                    echo "Tag description: ${tagDescription}"
                    
                    // Parse app version (4 parts)
                    def (appMajor, appMinor, appPatch, appBuild) = latestTag.replaceAll('v', '').tokenize('.')
                    
                    // Parse backend and frontend versions from description
                    def backendMatch = tagDescription =~ /backend: (\d+\.\d+\.\d+)/
                    def frontendMatch = tagDescription =~ /frontend: (\d+\.\d+\.\d+)/
                    
                    def backendVersion = backendMatch[0][1]
                    def frontendVersion = frontendMatch[0][1]
                    
                    def (backendMajor, backendMinor, backendPatch) = backendVersion.tokenize('.')
                    def (frontendMajor, frontendMinor, frontendPatch) = frontendVersion.tokenize('.')
                    
                    // Check for changes
                    def backendChanges = sh(
                        script: 'git diff --name-only HEAD~1..HEAD | grep "app/backend/" || true',
                        returnStdout: true
                    ).trim()

                    def frontendChanges = sh(
                        script: 'git diff --name-only HEAD~1..HEAD | grep "app/frontend/" || true',
                        returnStdout: true
                    ).trim()

                    env.BACKEND_CHANGED = backendChanges ? 'true' : 'false'
                    env.FRONTEND_CHANGED = frontendChanges ? 'true' : 'false'
                    
                    // Update versions based on commit message
                    if (commitMessage.startsWith('breaking')) {
                        appMinor = (appMinor.toInteger() + 1).toString()
                        appPatch = '0'
                        appBuild = '0'
                    } else if (commitMessage.startsWith('feat')) {
                        appPatch = (appPatch.toInteger() + 1).toString()
                        appBuild = '0'
                    } else if (commitMessage.startsWith('fix')) {
                        appBuild = (appBuild.toInteger() + 1).toString()
                    }
                    
                    // Update backend version if changed
                    if (env.BACKEND_CHANGED == 'true') {
                        if (commitMessage.startsWith('breaking')) {
                            backendMajor = (backendMajor.toInteger() + 1).toString()
                            backendMinor = '0'
                            backendPatch = '0'
                        } else if (commitMessage.startsWith('feat')) {
                            backendMinor = (backendMinor.toInteger() + 1).toString()
                            backendPatch = '0'
                        } else if (commitMessage.startsWith('fix')) {
                            backendPatch = (backendPatch.toInteger() + 1).toString()
                        }
                        env.BUILD_BACKEND = 'true'
                    }
                    
                    // Update frontend version if changed
                    if (env.FRONTEND_CHANGED == 'true') {
                        if (commitMessage.startsWith('breaking')) {
                            frontendMajor = (frontendMajor.toInteger() + 1).toString()
                            frontendMinor = '0'
                            frontendPatch = '0'
                        } else if (commitMessage.startsWith('feat')) {
                            frontendMinor = (frontendMinor.toInteger() + 1).toString()
                            frontendPatch = '0'
                        } else if (commitMessage.startsWith('fix')) {
                            frontendPatch = (frontendPatch.toInteger() + 1).toString()
                        }
                        env.BUILD_FRONTEND = 'true'
                    }
                    
                    // Set new versions
                    env.NEW_VERSION = "v${appMajor}.${appMinor}.${appPatch}.${appBuild}"
                    env.NEW_BACKEND_VERSION = "${backendMajor}.${backendMinor}.${backendPatch}"
                    env.NEW_FRONTEND_VERSION = "${frontendMajor}.${frontendMinor}.${frontendPatch}"
                    
                    echo "Setting versions:"
                    echo "App: ${env.NEW_VERSION}"
                    echo "Backend: ${env.NEW_BACKEND_VERSION}"
                    echo "Frontend: ${env.NEW_FRONTEND_VERSION}"
                    
                    // Set up other environment variables
                    env.GIT_COMMIT_HASH = sh(script: "git log -n 1 --pretty=format:'%H'", returnStdout: true).trim()
                    env.SHORT_COMMIT = env.GIT_COMMIT_HASH.substring(0, 7)
                    env.REPO_PATH = "ghcr.io/yisraelberman/positions"
                    
                    // Define image names with versions
                    env.BACKEND_IMAGE = "${env.REPO_PATH}/backend:${env.NEW_BACKEND_VERSION}"
                    env.FRONTEND_IMAGE = "${env.REPO_PATH}/frontend:${env.NEW_FRONTEND_VERSION}"

                    echo "Changes detected:"
                    echo "Backend changed: ${env.BACKEND_CHANGED}"
                    echo "Frontend changed: ${env.FRONTEND_CHANGED}"
                }
            }
        }        
        stage('Create Tag') {
            steps {
                script {
                    def tagMessage = """Release ${env.NEW_VERSION}
        backend: ${env.NEW_BACKEND_VERSION}
        frontend: ${env.NEW_FRONTEND_VERSION}"""

                    withCredentials([usernamePassword(credentialsId: 'github', 
                                                usernameVariable: 'GIT_USERNAME', 
                                                passwordVariable: 'GIT_PASSWORD')]) {
                        sh """
                            git config user.email "jenkins@example.com"
                            git config user.name "Jenkins"
                            git config credential.helper '!f() { echo "username=${GIT_USERNAME}"; echo "password=${GIT_PASSWORD}"; }; f'
                            git tag -a ${env.NEW_VERSION} -m "${tagMessage}"
                            git push https://github.com/YisraelBerman/positions.git ${env.NEW_VERSION}
                            git config --unset credential.helper
                        """
                    }
                }
            }
}
        
        stage('Test') {
            steps {
                echo 'To be added someday.'
            }
        }

        stage('Build') {
            parallel {
                stage('Build Backend') {
                    when {
                        expression {
                            return env.BACKEND_CHANGED == 'true'
                        }
                    }
                    steps {
                        script {
                            echo "Building backend image version ${env.NEW_BACKEND_VERSION}..."
                            sh "docker build -t ${env.BACKEND_IMAGE} -f ./app/backend/dockerfile ./app/backend"
                            env.BUILD_BACKEND = 'true'
                        }
                    }
                }
                stage('Build Frontend') {
                    when {
                        expression {
                            return env.FRONTEND_CHANGED == 'true'
                        }
                    }
                    steps {
                        script {
                            echo "Building frontend image version ${env.NEW_FRONTEND_VERSION}..."
                            sh "docker build --build-arg REACT_APP_BACKEND_URL=https://app.yisraelberman.com:5000 -t ${env.FRONTEND_IMAGE} -f ./app/frontend/dockerfile ./app/frontend"
                            env.BUILD_FRONTEND = 'true'
                        }
                    }
                }
            }
        }

        stage('Docker Login') {
            when {
                expression { return env.BUILD_BACKEND == 'true' || env.BUILD_FRONTEND == 'true' }
            }
            steps {
                sh "echo ${env.GITHUB_TOKEN} | docker login ghcr.io -u ${env.GITHUB_USER} --password-stdin"
            }
        }

        stage('Push Images to GitHub') {
            parallel {
                stage('Push Backend Image') {
                    when {
                        expression { return env.BUILD_BACKEND == 'true' }
                    }
                    steps {
                        script {
                            echo "Pushing backend image version ${env.NEW_BACKEND_VERSION}..."
                            sh "docker push ${env.BACKEND_IMAGE}"
                        }
                    }
                }
                stage('Push Frontend Image') {
                    when {
                        expression { return env.BUILD_FRONTEND == 'true' }
                    }
                    steps {
                        script {
                            echo "Pushing frontend image version ${env.NEW_FRONTEND_VERSION}..."
                            sh "docker push ${env.FRONTEND_IMAGE}"
                        }
                    }
                }
            }
        }

        stage('Deploy') {
            when {
                expression { return env.BUILD_BACKEND == 'true' || env.BUILD_FRONTEND == 'true' }
            }
            steps {
                script {
                    withCredentials([sshUserPrivateKey(credentialsId: 'forssh', keyFileVariable: 'secret')]) {
                        if (env.BUILD_BACKEND == 'true') {
                            sh """
                            ssh -o StrictHostKeyChecking=no -i "$secret" ${env.SSH_TARGET} "
                                sudo docker stop backend || true && sudo docker rm backend || true && \
                                sudo docker pull ${env.BACKEND_IMAGE} && \
                                sudo docker run -d --name backend -p 5000:5000 \
                                -e FLASK_ENV=production \
                                -e CORS_ORIGIN=https://app.yisraelberman.com \
                                -v /etc/letsencrypt/live/app.yisraelberman.com/fullchain.pem:/etc/letsencrypt/live/app.yisraelberman.com/fullchain.pem:ro \
                                -v /etc/letsencrypt/live/app.yisraelberman.com/privkey.pem:/etc/letsencrypt/live/app.yisraelberman.com/privkey.pem:ro \
                                ${env.BACKEND_IMAGE}
                            "
                            """
                        }

                        if (env.BUILD_FRONTEND == 'true') {
                            sh """
                            ssh -o StrictHostKeyChecking=no -i "$secret" ${env.SSH_TARGET} "
                                sudo docker stop frontend || true && sudo docker rm frontend || true;
                                sudo docker pull ${env.FRONTEND_IMAGE};
                                sudo docker run -d --name frontend -p 443:3002 \\
                                -e REACT_APP_BACKEND_URL=https://app.yisraelberman.com:5000 \\
                                -v /etc/letsencrypt/live/app.yisraelberman.com/fullchain.pem:/etc/letsencrypt/live/app.yisraelberman.com/fullchain.pem:ro \\
                                -v /etc/letsencrypt/live/app.yisraelberman.com/privkey.pem:/etc/letsencrypt/live/app.yisraelberman.com/privkey.pem:ro \\
                                ${env.FRONTEND_IMAGE};
                            "
                            """
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            cleanWs()
        }
    }
}