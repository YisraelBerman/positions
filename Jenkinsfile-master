pipeline {
    agent {
        label 'agent1'
    }

    environment {
        GITHUB_TOKEN = credentials('github-token')
        GITHUB_USER = credentials('github-user')
        AWS_APPS_IP = credentials('AWS_apps_IP') 
        SSH_TARGET = "ubuntu@${env.AWS_APPS_IP}"
    }

    stages {  
        // Replace the version parsing section with this more robust version:

        stage('Initialize and Get Versions') {
            steps {
                script {
                    // Ensure we have full history and tags
                    checkout([$class: 'GitSCM',
                            branches: [[name: '*/master']],
                            extensions: [[$class: 'CloneOption',
                                        noTags: false,
                                        shallow: false,
                                        depth: 0,
                                        reference: '']],
                            userRemoteConfigs: [[
                                credentialsId: 'github',
                                url: 'https://github.com/YisraelBerman/positions.git'
                            ]]])
                    
                    // Get commit message
                    def commitMessage = sh(
                        script: "git log -1 --pretty=%B",
                        returnStdout: true
                    ).trim().toLowerCase()
                    
                    // Initialize default versions
                    env.NEW_VERSION = 'v1.0.0.0'
                    env.NEW_BACKEND_VERSION = '1.0.0'
                    env.NEW_FRONTEND_VERSION = '1.0.0'
                    
                    // Try to get the latest tag
                    def latestTag = sh(
                        script: 'git tag -l | sort -V | tail -n1 || true',
                        returnStdout: true
                    ).trim()
                    
                    if (latestTag) {
                        echo "Found latest tag: ${latestTag}"
                        
                        // Get tag description
                        def tagDescription = sh(
                            script: "git tag -l --format='%(contents)' ${latestTag} || true",
                            returnStdout: true
                        ).trim()
                        
                        echo "Tag description: ${tagDescription}"
                        
                        // Parse app version (4 parts)
                        def appVersionParts = latestTag.replaceAll('v', '').tokenize('.')
                        if (appVersionParts.size() == 4) {
                            def (appMajor, appMinor, appPatch, appBuild) = appVersionParts
                            
                            // Parse component versions from description
                            def backendMatch = tagDescription =~ /backend: (\d+\.\d+\.\d+)/
                            def frontendMatch = tagDescription =~ /frontend: (\d+\.\d+\.\d+)/
                            
                            def backendVersion = backendMatch.find() ? backendMatch.group(1) : '1.0.0'
                            def frontendVersion = frontendMatch.find() ? frontendMatch.group(1) : '1.0.0'
                            
                            def backendParts = backendVersion.tokenize('.')
                            def frontendParts = frontendVersion.tokenize('.')
                            
                            // Update versions based on commit message
                            if (commitMessage.startsWith('breaking')) {
                                appMinor = (appMinor.toInteger() + 1).toString()
                                appPatch = '0'
                                appBuild = '0'
                            } else if (commitMessage.startsWith('feat')) {
                                appPatch = (appPatch.toInteger() + 1).toString()
                                appBuild = '0'
                            } else if (commitMessage.startsWith('fix')) {
                                appBuild = (appBuild.toInteger() + 1).toString()
                            }
                            
                            // Update backend version if changed
                            if (env.BACKEND_CHANGED == 'true') {
                                def (bMajor, bMinor, bPatch) = backendParts
                                if (commitMessage.startsWith('breaking')) {
                                    bMajor = (bMajor.toInteger() + 1).toString()
                                    bMinor = '0'
                                    bPatch = '0'
                                } else if (commitMessage.startsWith('feat')) {
                                    bMinor = (bMinor.toInteger() + 1).toString()
                                    bPatch = '0'
                                } else if (commitMessage.startsWith('fix')) {
                                    bPatch = (bPatch.toInteger() + 1).toString()
                                }
                                env.NEW_BACKEND_VERSION = "${bMajor}.${bMinor}.${bPatch}"
                            } else {
                                env.NEW_BACKEND_VERSION = backendVersion
                            }
                            
                            // Update frontend version if changed
                            if (env.FRONTEND_CHANGED == 'true') {
                                def (fMajor, fMinor, fPatch) = frontendParts
                                if (commitMessage.startsWith('breaking')) {
                                    fMajor = (fMajor.toInteger() + 1).toString()
                                    fMinor = '0'
                                    fPatch = '0'
                                } else if (commitMessage.startsWith('feat')) {
                                    fMinor = (fMinor.toInteger() + 1).toString()
                                    fPatch = '0'
                                } else if (commitMessage.startsWith('fix')) {
                                    fPatch = (fPatch.toInteger() + 1).toString()
                                }
                                env.NEW_FRONTEND_VERSION = "${fMajor}.${fMinor}.${fPatch}"
                            } else {
                                env.NEW_FRONTEND_VERSION = frontendVersion
                            }
                            
                            env.NEW_VERSION = "v${appMajor}.${appMinor}.${appPatch}.${appBuild}"
                        }
                    }
                    
                    echo "Setting versions:"
                    echo "App: ${env.NEW_VERSION}"
                    echo "Backend: ${env.NEW_BACKEND_VERSION}"
                    echo "Frontend: ${env.NEW_FRONTEND_VERSION}"
                    
                    // Set up other environment variables
                    env.GIT_COMMIT_HASH = sh(script: "git log -n 1 --pretty=format:'%H'", returnStdout: true).trim()
                    env.SHORT_COMMIT = env.GIT_COMMIT_HASH.substring(0, 7)
                    env.REPO_PATH = "ghcr.io/yisraelberman/positions"
                    
                    // Define image names with versions
                    env.BACKEND_IMAGE = "${env.REPO_PATH}/backend:${env.NEW_BACKEND_VERSION}"
                    env.FRONTEND_IMAGE = "${env.REPO_PATH}/frontend:${env.NEW_FRONTEND_VERSION}"
                    
                    // Initialize build flags
                    env.BUILD_BACKEND = 'false'
                    env.BUILD_FRONTEND = 'false'
                    
                    // Check for changes if not already set
                    if (!env.BACKEND_CHANGED || !env.FRONTEND_CHANGED) {
                        def backendChanges = sh(
                            script: 'git diff --name-only HEAD~1..HEAD | grep "app/backend/" || true',
                            returnStdout: true
                        ).trim()

                        def frontendChanges = sh(
                            script: 'git diff --name-only HEAD~1..HEAD | grep "app/frontend/" || true',
                            returnStdout: true
                        ).trim()

                        env.BACKEND_CHANGED = backendChanges ? 'true' : 'false'
                        env.FRONTEND_CHANGED = frontendChanges ? 'true' : 'false'
                    }

                    echo "Changes detected:"
                    echo "Backend changed: ${env.BACKEND_CHANGED}"
                    echo "Frontend changed: ${env.FRONTEND_CHANGED}"
                }
            }
        }
        stage('Create Tag') {
            steps {
                script {
                    def tagMessage = """Release ${env.NEW_VERSION}
backend: ${env.NEW_BACKEND_VERSION}
frontend: ${env.NEW_FRONTEND_VERSION}"""

                    withCredentials([usernamePassword(credentialsId: 'github', 
                                                   usernameVariable: 'GIT_USERNAME', 
                                                   passwordVariable: 'GIT_PASSWORD')]) {
                        sh """
                            git config user.email "jenkins@example.com"
                            git config user.name "Jenkins"
                            git config credential.helper '!f() { echo "username=${GIT_USERNAME}"; echo "password=${GIT_PASSWORD}"; }; f'
                            git tag -a ${env.NEW_VERSION} -m "${tagMessage}"
                            git push https://github.com/YisraelBerman/positions.git ${env.NEW_VERSION}
                            git config --unset credential.helper
                        """
                    }
                }
            }
        }
        
        stage('Test') {
            steps {
                echo 'To be added someday.'
            }
        }

        stage('Build') {
            parallel {
                stage('Build Backend') {
                    when {
                        expression {
                            return env.BACKEND_CHANGED == 'true'
                        }
                    }
                    steps {
                        script {
                            echo "Building backend image version ${env.NEW_BACKEND_VERSION}..."
                            sh "docker build -t ${env.BACKEND_IMAGE} -f ./app/backend/dockerfile ./app/backend"
                            env.BUILD_BACKEND = 'true'
                        }
                    }
                }
                stage('Build Frontend') {
                    when {
                        expression {
                            return env.FRONTEND_CHANGED == 'true'
                        }
                    }
                    steps {
                        script {
                            echo "Building frontend image version ${env.NEW_FRONTEND_VERSION}..."
                            sh "docker build --build-arg REACT_APP_BACKEND_URL=https://app.yisraelberman.com:5000 -t ${env.FRONTEND_IMAGE} -f ./app/frontend/dockerfile ./app/frontend"
                            env.BUILD_FRONTEND = 'true'
                        }
                    }
                }
            }
        }

        stage('Docker Login') {
            when {
                expression { return env.BUILD_BACKEND == 'true' || env.BUILD_FRONTEND == 'true' }
            }
            steps {
                sh "echo ${env.GITHUB_TOKEN} | docker login ghcr.io -u ${env.GITHUB_USER} --password-stdin"
            }
        }

        stage('Push Images to GitHub') {
            parallel {
                stage('Push Backend Image') {
                    when {
                        expression { return env.BUILD_BACKEND == 'true' }
                    }
                    steps {
                        script {
                            echo "Pushing backend image version ${env.NEW_BACKEND_VERSION}..."
                            sh "docker push ${env.BACKEND_IMAGE}"
                        }
                    }
                }
                stage('Push Frontend Image') {
                    when {
                        expression { return env.BUILD_FRONTEND == 'true' }
                    }
                    steps {
                        script {
                            echo "Pushing frontend image version ${env.NEW_FRONTEND_VERSION}..."
                            sh "docker push ${env.FRONTEND_IMAGE}"
                        }
                    }
                }
            }
        }

        stage('Deploy') {
            when {
                expression { return env.BUILD_BACKEND == 'true' || env.BUILD_FRONTEND == 'true' }
            }
            steps {
                script {
                    withCredentials([sshUserPrivateKey(credentialsId: 'forssh', keyFileVariable: 'secret')]) {
                        if (env.BUILD_BACKEND == 'true') {
                            sh """
                            ssh -o StrictHostKeyChecking=no -i "$secret" ${env.SSH_TARGET} "
                                sudo docker stop backend || true && sudo docker rm backend || true && \
                                sudo docker pull ${env.BACKEND_IMAGE} && \
                                sudo docker run -d --name backend -p 5000:5000 \
                                -e FLASK_ENV=production \
                                -e CORS_ORIGIN=https://app.yisraelberman.com \
                                -v /etc/letsencrypt/live/app.yisraelberman.com/fullchain.pem:/etc/letsencrypt/live/app.yisraelberman.com/fullchain.pem:ro \
                                -v /etc/letsencrypt/live/app.yisraelberman.com/privkey.pem:/etc/letsencrypt/live/app.yisraelberman.com/privkey.pem:ro \
                                ${env.BACKEND_IMAGE}
                            "
                            """
                        }

                        if (env.BUILD_FRONTEND == 'true') {
                            sh """
                            ssh -o StrictHostKeyChecking=no -i "$secret" ${env.SSH_TARGET} "
                                sudo docker stop frontend || true && sudo docker rm frontend || true;
                                sudo docker pull ${env.FRONTEND_IMAGE};
                                sudo docker run -d --name frontend -p 443:3002 \\
                                -e REACT_APP_BACKEND_URL=https://app.yisraelberman.com:5000 \\
                                -v /etc/letsencrypt/live/app.yisraelberman.com/fullchain.pem:/etc/letsencrypt/live/app.yisraelberman.com/fullchain.pem:ro \\
                                -v /etc/letsencrypt/live/app.yisraelberman.com/privkey.pem:/etc/letsencrypt/live/app.yisraelberman.com/privkey.pem:ro \\
                                ${env.FRONTEND_IMAGE};
                            "
                            """
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            cleanWs()
        }
    }
}