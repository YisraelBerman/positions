pipeline {
    agent {
        label 'agent1'
    }

    environment {
        GITHUB_TOKEN = credentials('github-token')
        GITHUB_USER = credentials('github-user')      
        AWS_INSTANCE_ID = credentials('dev-instance-ID')
        SSH_KEY_CREDENTIALS = credentials('forssh')
        AWS_REGION = 'us-east-1' 
        AWS_ACCESS_KEY_ID = credentials('aws-access-key') // AWS Access Key from Jenkins Credentials
        AWS_SECRET_ACCESS_KEY = credentials('aws-secret-key') // AWS Secret Key from Jenkins Credentials
        
        REPO_BASE_PATH = "ghcr.io/yisraelberman/positions"
        
    }




    stages { 

        stage('AWS CLI Setup') {
            steps {
                script {
                    // Check if unzip is installed, and install it if not
                    def unzipInstalled = sh(script: 'which unzip', returnStatus: true)
                    if (unzipInstalled != 0) {
                        sh 'apt-get update && apt-get install -y unzip'
                    }

                    // Check if AWS CLI is installed
                    def awsCliInstalled = sh(script: 'which aws', returnStatus: true)
                    
                    // Install AWS CLI if not installed
                    if (awsCliInstalled != 0) {
                        sh '''
                            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                            unzip awscliv2.zip
                            ./aws/install
                        '''
                    }
                    
                    // Configure AWS CLI with the provided credentials
                    sh '''
                        aws configure set aws_access_key_id ${AWS_ACCESS_KEY_ID}
                        aws configure set aws_secret_access_key ${AWS_SECRET_ACCESS_KEY}
                        aws configure set region ${AWS_REGION}
                    '''
                }
            }
        } //AWS CLI Setup

        stage('Check EC2 Instance State') {
            steps {
                script {
                    withCredentials([string(credentialsId: 'dev-instance-ID', variable: 'INSTANCE_ID')]) {
                        // Check instance state and set environment variable
                        env.INSTANCE_STATE = sh(script: '''
                            aws ec2 describe-instances --instance-ids ${INSTANCE_ID} \
                            --query 'Reservations[*].Instances[*].State.Name' --output text --region ${AWS_REGION}
                        ''', returnStdout: true).trim()
                        echo "Instance state: ${env.INSTANCE_STATE}"

                        // Retrieve and set the instance public IP
                        env.AWS_APPS_IP = sh(script: '''
                            aws ec2 describe-instances --instance-ids ${INSTANCE_ID} \
                            --query 'Reservations[*].Instances[*].PublicIpAddress' --output text --region ${AWS_REGION}
                        ''', returnStdout: true).trim()
                        env.SSH_TARGET = "ubuntu@${env.AWS_APPS_IP}"
                        echo "Instance public IP: ${env.AWS_APPS_IP}"
                    }
                }
            }
        }// Check EC2 Instance State

        stage('Start AWS EC2 Instance') {
            when {
                expression { return env.INSTANCE_STATE != 'running' }
            }
            steps {
                script {
                    withCredentials([string(credentialsId: 'dev-instance-ID', variable: 'INSTANCE_ID')]) {
                        echo "Starting instance..."
                        sh '''
                            aws ec2 start-instances --instance-ids ${INSTANCE_ID} --region ${AWS_REGION}
                            aws ec2 wait instance-running --instance-ids ${INSTANCE_ID} --region ${AWS_REGION}
                        '''
                        echo "Instance is now running."

                        // Retrieve and set the public IP
                        env.AWS_APPS_IP = sh(script: '''
                            aws ec2 describe-instances --instance-ids ${INSTANCE_ID} \
                            --query 'Reservations[*].Instances[*].PublicIpAddress' --output text --region ${AWS_REGION}
                        ''', returnStdout: true).trim()
                        env.SSH_TARGET = "ubuntu@${env.AWS_APPS_IP}"
                        echo "Instance public IP: ${env.AWS_APPS_IP}"
                    }

                    // Wait for SSH to be available by testing an SSH connection in a loop
                    withCredentials([sshUserPrivateKey(credentialsId: 'forssh', keyFileVariable: 'SSH_KEY_PATH')]) {
                        timeout(time: 2, unit: 'MINUTES') {
                            waitUntil {
                                script {
                                    echo "Attempting SSH connection to ${env.SSH_TARGET}..."
                                    def sshReady = sh(script: "ssh -o BatchMode=yes -o ConnectTimeout=5 -o StrictHostKeyChecking=no -i \"$SSH_KEY_PATH\" ${env.SSH_TARGET} 'echo SSH is ready'", returnStatus: true)
                                    
                                    if (sshReady == 0) {
                                        echo "SSH connection successful."
                                        return true
                                    } else {
                                        echo "SSH connection attempt failed. Retrying..."
                                        return false
                                    }
                                }
                            }
                        }

                        // Run on_start.sh after SSH is confirmed available
                        sh '''
                            ssh -o StrictHostKeyChecking=no -i "$SSH_KEY_PATH" ${SSH_TARGET} 'bash ~/on_start.sh'
                        '''
                    }            
                    
                }
            }
        } //Start AWS EC2 Instance       
        
        stage('Initialize') {
            steps {
                script {
                    // Define services configuration
                    def services = [
                        [
                            name: 'backend',
                            directory: 'app/backend',
                            port: '5000',
                            envFile: '~/backend/.env',
                            extraEnv: [
                                'FLASK_ENV=production',
                                'CORS_ORIGIN=https://app-dev.yisraelberman.com'
                            ],
                            buildArgs: []
                        ],
                        [
                            name: 'frontend',
                            directory: 'app/frontend',
                            port: '443:3002',
                            envFile: '',
                            extraEnv: [
                                'REACT_APP_BACKEND_URL=https://app-dev.yisraelberman.com:5000'
                            ],
                            buildArgs: [
                                'REACT_APP_BACKEND_URL=https://app-dev.yisraelberman.com:5000'
                            ]
                        ]
                        // Add new services here following the same pattern
                        //[
                        //    name: 'newservice',
                        //    directory: 'app/newservice',
                        //    port: '8080:8080',
                        //    envFile: '~/newservice/.env',
                        //    extraEnv: [
                        //        'ENV_VAR1=value1',
                        //        'ENV_VAR2=value2'
                        //    ],
                        //    buildArgs: [
                        //        'BUILD_ARG1=value1'
                        //   ]
                        //]
                    ]
                    
                    // Store services in environment for use in other stages
                    env.SERVICES = groovy.json.JsonOutput.toJson(services)
                    
                    // Fetch git information
                    env.GIT_COMMIT_HASH = sh(script: "git log -n 1 --pretty=format:'%H'", returnStdout: true).trim()
                    env.SHORT_COMMIT = env.GIT_COMMIT_HASH.substring(0, 7)
                    def branchName = env.BRANCH_NAME.replaceAll('/', '-')
                    
                    // Initialize service-specific variables
                    def servicesConfig = readJSON text: env.SERVICES
                    servicesConfig.each { service ->
                        env["${service.name.toUpperCase()}_IMAGE"] = "${REPO_BASE_PATH}/${service.name}:${branchName}-build-${BUILD_NUMBER}"
                        env["BUILD_${service.name.toUpperCase()}"] = 'false'
                    }
                }
            }
        } // Initialize

        
        stage('Test') {
            steps {
                echo 'To be added someday.'
            }
        } // test

        stage('Check for Changes') {
            steps {
                script {
                    def servicesConfig = readJSON text: env.SERVICES
                    servicesConfig.each { service ->
                        def changes = sh(
                            script: "git diff --name-only HEAD~1..HEAD | grep '${service.directory}/' || true",
                            returnStdout: true
                        ).trim()
                        
                        env["${service.name.toUpperCase()}_CHANGED"] = changes ? 'true' : 'false'
                        echo "${service.name} Changed: ${env["${service.name.toUpperCase()}_CHANGED"]}"
                    }
                }
            }
        } //Check for Changes

        stage('Build') {
            steps {
                script {
                    def servicesConfig = readJSON text: env.SERVICES
                    servicesConfig.each { service ->
                        if (env["${service.name.toUpperCase()}_CHANGED"] == 'true') {
                            echo "Changes detected in ${service.name}. Building image..."
                            def buildArgs = service.buildArgs.collect { arg -> "--build-arg ${arg}" }.join(' ')
                            sh """
                                docker build ${buildArgs} \
                                -t ${env["${service.name.toUpperCase()}_IMAGE"]} \
                                -f ./${service.directory}/dockerfile \
                                ./${service.directory}
                            """
                            env["BUILD_${service.name.toUpperCase()}"] = 'true'
                        }
                    }
                }
            }
        } // Build

        stage('Docker Login') {
            when {
                expression { 
                    def servicesConfig = readJSON text: env.SERVICES
                    return servicesConfig.any { service ->
                        env["BUILD_${service.name.toUpperCase()}"] == 'true'
                    }
                }
            }
            steps {
                sh "echo ${env.GITHUB_TOKEN} | docker login ghcr.io -u ${env.GITHUB_USER} --password-stdin"
            }
        } // Docker Login

        stage('Push Images') {
            steps {
                script {
                    def servicesConfig = readJSON text: env.SERVICES
                    servicesConfig.each { service ->
                        if (env["BUILD_${service.name.toUpperCase()}"] == 'true') {
                            echo "Pushing ${service.name} image to GitHub..."
                            sh "docker push ${env["${service.name.toUpperCase()}_IMAGE"]}"
                        }
                    }
                }
            }
        } // Push Images to GitHub

        stage('Deploy') {
            when {
                expression { 
                    def servicesConfig = readJSON text: env.SERVICES
                    return servicesConfig.any { service ->
                        env["BUILD_${service.name.toUpperCase()}"] == 'true'
                    }
                }
            }
            steps {
                script {
                    def servicesConfig = readJSON text: env.SERVICES
                    withCredentials([sshUserPrivateKey(credentialsId: 'forssh', keyFileVariable: 'secret')]) {
                        withEnv(["SSH_KEY_PATH=$secret"]) {
                            servicesConfig.each { service ->
                                if (env["BUILD_${service.name.toUpperCase()}"] == 'true') {
                                    echo "Deploying ${service.name}..."
                                    def envFile = service.envFile ? "--env-file ${service.envFile}" : ''
                                    def extraEnv = service.extraEnv.collect { "-e ${it}" }.join(' ')
                                    
                                    sh """
                                        ssh -o StrictHostKeyChecking=no -i "\$SSH_KEY_PATH" \${SSH_TARGET} "
                                            sudo docker stop ${service.name} || true && \
                                            sudo docker rm ${service.name} || true && \
                                            sudo docker pull ${env["${service.name.toUpperCase()}_IMAGE"]} && \
                                            sudo docker run -d --name ${service.name} \
                                            -p ${service.port} \
                                            ${envFile} \
                                            ${extraEnv} \
                                            -v /etc/letsencrypt/live/app-dev.yisraelberman.com-0001/fullchain.pem:/etc/letsencrypt/live/app.yisraelberman.com/fullchain.pem:ro \
                                            -v /etc/letsencrypt/live/app-dev.yisraelberman.com-0001/privkey.pem:/etc/letsencrypt/live/app.yisraelberman.com/privkey.pem:ro \
                                            ${env["${service.name.toUpperCase()}_IMAGE"]}
                                        "
                                    """
                                }
                            }
                        }
                    }
                }
            }
        } // Deploy

    } //stages

    post {
        always {
            // Clean up the workspace
            cleanWs()
        }
    }
}
